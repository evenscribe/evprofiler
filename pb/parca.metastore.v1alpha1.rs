// This file is @generated by prost-build.
/// GetOrCreateMappingsRequest contains all information about mappings that are
/// requested to be retrieved or created if they don't already exist.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrCreateMappingsRequest {
    /// Mappings to be created or retrieved.
    #[prost(message, repeated, tag = "1")]
    pub mappings: ::prost::alloc::vec::Vec<Mapping>,
}
/// GetOrCreateMappingsResponse contains information about mappings requested.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrCreateMappingsResponse {
    /// Mappings that are known to the backing metastore. If any mappings didn't
    /// exist before the request they have now been persisted and are uniquely
    /// identifyable through their key.
    #[prost(message, repeated, tag = "1")]
    pub mappings: ::prost::alloc::vec::Vec<Mapping>,
}
/// GetOrCreateFunctionsRequest contains all information about functions that are
/// requested to be retrieved or created if they don't already exist.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrCreateFunctionsRequest {
    /// Functions to be created or retrieved.
    #[prost(message, repeated, tag = "1")]
    pub functions: ::prost::alloc::vec::Vec<Function>,
}
/// GetOrCreateFunctionsResponse contains information about functions requested.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrCreateFunctionsResponse {
    /// Functions that are known to the backing metastore. If any functions didn't
    /// exist before the request they have now been persisted and are uniquely
    /// identifyable through their key.
    #[prost(message, repeated, tag = "1")]
    pub functions: ::prost::alloc::vec::Vec<Function>,
}
/// GetOrCreateLocationsRequest contains all information about locations that are
/// requested to be retrieved or created if they don't already exist.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrCreateLocationsRequest {
    /// Locations to be created or retrieved.
    #[prost(message, repeated, tag = "1")]
    pub locations: ::prost::alloc::vec::Vec<Location>,
}
/// GetOrCreateLocationsResponse contains information about locations requested.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrCreateLocationsResponse {
    /// Locations that are known to the backing metastore. If any locations didn't
    /// exist before the request they have now been persisted and are uniquely
    /// identifyable through their key.
    #[prost(message, repeated, tag = "1")]
    pub locations: ::prost::alloc::vec::Vec<Location>,
}
/// GetOrCreateStracktracesRequest contains all information about stacktraces
/// that are requested to be retrieved or created if they don't already exist.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrCreateStacktracesRequest {
    /// Stacktraces to be created or retrieved.
    #[prost(message, repeated, tag = "1")]
    pub stacktraces: ::prost::alloc::vec::Vec<Stacktrace>,
}
/// GetOrCreateStacktracesResponse contains information about locations requested.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrCreateStacktracesResponse {
    /// Stacktraces that are known to the backing metastore. If any stacktraces
    /// didn't exist before the request they have now been persisted and are
    /// uniquely identifyable through their key.
    #[prost(message, repeated, tag = "1")]
    pub stacktraces: ::prost::alloc::vec::Vec<Stacktrace>,
}
/// UnsymbolizedLocationsRequest contains information about the unsymbolized
/// locations requested. While currently empty, this could in the future contain
/// a sharding configuration or limit the number of locations to return.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnsymbolizedLocationsRequest {
    /// The maximum number of locations to return.
    #[prost(uint32, tag = "1")]
    pub limit: u32,
    /// The minimum key to start returning locations from.
    #[prost(string, tag = "2")]
    pub min_key: ::prost::alloc::string::String,
}
/// UnsymbolizedLocationsResponse contains information about the requested
/// locations that should be symbolizable but potentially haven't been
/// symbolized yet.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnsymbolizedLocationsResponse {
    /// Locations that have a mapping and address that should be symbolizable.
    #[prost(message, repeated, tag = "1")]
    pub locations: ::prost::alloc::vec::Vec<Location>,
    /// Key of the last location returned. This can be used in a subsequent call
    /// to UnsymbolizedLocations to continue from the last returned location.
    #[prost(string, tag = "2")]
    pub max_key: ::prost::alloc::string::String,
}
/// CreateLocationLinesRequest contains locations and their location lines to be
/// saved.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateLocationLinesRequest {
    /// Locations that have location lines to be saved.
    #[prost(message, repeated, tag = "1")]
    pub locations: ::prost::alloc::vec::Vec<Location>,
}
/// CreateLocationLinesResponse details about the location lines creation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateLocationLinesResponse {}
/// StacktracesRequest contains information about the stacktraces requested.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StacktracesRequest {
    /// IDs of stacktraces to retrieve.
    #[prost(string, repeated, tag = "1")]
    pub stacktrace_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// StacktracesRequest contains the requested stacktraces.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StacktracesResponse {
    /// Stacktraces that are known to the backing metastore.
    #[prost(message, repeated, tag = "1")]
    pub stacktraces: ::prost::alloc::vec::Vec<Stacktrace>,
}
/// LocationsRequest contains information about the locations requested.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationsRequest {
    /// IDs of locations to retrieve.
    #[prost(string, repeated, tag = "1")]
    pub location_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// LocationsResponse contains the requested locations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationsResponse {
    /// Locations that are known to the backing metastore.
    #[prost(message, repeated, tag = "1")]
    pub locations: ::prost::alloc::vec::Vec<Location>,
}
/// LocationLinesRequest contains information about the location's lines requested.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationLinesRequest {
    /// IDs of locations to retrieve location lines for.
    #[prost(string, repeated, tag = "1")]
    pub location_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// FunctionsRequest contains information about the functions requested.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionsRequest {
    /// IDs of functions to retrieve.
    #[prost(string, repeated, tag = "1")]
    pub function_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// FunctionsResponse contains the requested functions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionsResponse {
    /// Functions that are known to the backing metastore.
    #[prost(message, repeated, tag = "1")]
    pub functions: ::prost::alloc::vec::Vec<Function>,
}
/// MappingsRequest contains information about the mappings requested.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MappingsRequest {
    /// IDs of mappings to retrieve.
    #[prost(string, repeated, tag = "1")]
    pub mapping_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// MappingsResponse contains the requested mappings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MappingsResponse {
    /// Mappings that are known to the backing metastore.
    #[prost(message, repeated, tag = "1")]
    pub mappings: ::prost::alloc::vec::Vec<Mapping>,
}
/// Sample is a stack trace with optional labels.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sample {
    /// stacktrace_id references stack trace of the sample.
    #[prost(string, tag = "1")]
    pub stacktrace_id: ::prost::alloc::string::String,
    /// labels are extra labels for a stack trace.
    #[prost(map = "string, message", tag = "2")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, SampleLabel>,
    /// num_labels are the num of labels.
    #[prost(map = "string, message", tag = "3")]
    pub num_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        SampleNumLabel,
    >,
    /// num_units are the units for the labels.
    #[prost(map = "string, message", tag = "4")]
    pub num_units: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        SampleNumUnit,
    >,
}
/// Stacktrace is a collection of locations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stacktrace {
    /// stacktrace_id references stack trace of the stacktrace.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// locations are the locations in the stack trace.
    #[prost(string, repeated, tag = "2")]
    pub location_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// SampleLabel are the labels added to a Sample.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SampleLabel {
    /// labels for a label in a Sample.
    #[prost(string, repeated, tag = "1")]
    pub labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// SampleNumLabel are the num of labels of a Sample.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SampleNumLabel {
    /// num_labels are the num_label of a Sample.
    #[prost(int64, repeated, tag = "1")]
    pub num_labels: ::prost::alloc::vec::Vec<i64>,
}
/// SampleNumUnit are the num units of a Sample.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SampleNumUnit {
    /// units of a labels of a Sample.
    #[prost(string, repeated, tag = "1")]
    pub units: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Location describes a single location of a stack traces.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Location {
    /// id is the unique identifier for the location.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// address is the memory address of the location if present.
    #[prost(uint64, tag = "2")]
    pub address: u64,
    /// mapping_id is the unique identifier for the mapping associated with the location.
    #[prost(string, tag = "4")]
    pub mapping_id: ::prost::alloc::string::String,
    /// is_folded indicates whether the location is folded into the previous location.
    #[prost(bool, tag = "5")]
    pub is_folded: bool,
    /// lines are the call frames represented by this location. Multiple lines
    /// indicate they have been inlined.
    #[prost(message, repeated, tag = "6")]
    pub lines: ::prost::alloc::vec::Vec<Line>,
    /// mapping_index has the index into the mapping table where mappings are sent deduplicated.
    #[prost(uint32, tag = "7")]
    pub mapping_index: u32,
}
/// Line describes a source code function and its line number.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Line {
    /// function_id is the ID of the function.
    #[prost(string, tag = "1")]
    pub function_id: ::prost::alloc::string::String,
    /// line is the line number in the source file of the referenced function.
    #[prost(int64, tag = "2")]
    pub line: i64,
    /// function_index is the index in the functions table.
    #[prost(uint32, tag = "3")]
    pub function_index: u32,
}
/// Function describes metadata of a source code function.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Function {
    /// id is the unique identifier for the function.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// start_line is the line number in the source file of the first line of the function.
    #[prost(int64, tag = "2")]
    pub start_line: i64,
    /// name is the name of the function.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// system_name describes the name of the function, as identified by the
    /// system. For instance, it can be a C++ mangled name.
    #[prost(string, tag = "4")]
    pub system_name: ::prost::alloc::string::String,
    /// filename is the name of the source file of the function.
    #[prost(string, tag = "5")]
    pub filename: ::prost::alloc::string::String,
    /// name_string_index is the index in the string table to the name associated with the function.
    #[prost(uint32, tag = "6")]
    pub name_string_index: u32,
    /// system_name_string_index is the index in the string table to the system_name associated with the function.
    #[prost(uint32, tag = "7")]
    pub system_name_string_index: u32,
    /// filename_string_index is the index in the string table to the filename associated with the function.
    #[prost(uint32, tag = "8")]
    pub filename_string_index: u32,
}
/// Mapping describes a memory mapping.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mapping {
    /// id is the unique identifier for the mapping.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// start is the start address of the mapping.
    #[prost(uint64, tag = "2")]
    pub start: u64,
    /// limit is the length of the address space of the mapping.
    #[prost(uint64, tag = "3")]
    pub limit: u64,
    /// offset in the binary that corresponds to the first mapped address.
    #[prost(uint64, tag = "4")]
    pub offset: u64,
    /// file is the name of the file associated with the mapping.
    #[prost(string, tag = "5")]
    pub file: ::prost::alloc::string::String,
    /// build_id is the build ID of the mapping.
    #[prost(string, tag = "6")]
    pub build_id: ::prost::alloc::string::String,
    /// has_functions indicates whether the mapping has associated functions.
    #[prost(bool, tag = "7")]
    pub has_functions: bool,
    /// has_filenames indicates whether the mapping has associated filenames.
    #[prost(bool, tag = "8")]
    pub has_filenames: bool,
    /// has_line_numbers indicates whether the mapping has associated line numbers.
    #[prost(bool, tag = "9")]
    pub has_line_numbers: bool,
    /// has_inline_frames indicates whether the mapping has associated inline frames.
    #[prost(bool, tag = "10")]
    pub has_inline_frames: bool,
    /// fileStringIndex is the index in the string table to the file name associated with the mapping.
    #[prost(uint32, tag = "11")]
    pub file_string_index: u32,
    /// build_id_string_index is the index in the string table to the build ID of the mapping.
    #[prost(uint32, tag = "12")]
    pub build_id_string_index: u32,
}
/// Generated server implementations.
pub mod metastore_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with MetastoreServiceServer.
    #[async_trait]
    pub trait MetastoreService: std::marker::Send + std::marker::Sync + 'static {
        /// GetOrCreateMappings checks if the mappings in the request are already
        /// known and returns the known mapping (including its ID) if so. If a mapping
        /// does not already exist, it is written to the backing metastore.
        async fn get_or_create_mappings(
            &self,
            request: tonic::Request<super::GetOrCreateMappingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetOrCreateMappingsResponse>,
            tonic::Status,
        >;
        /// GetOrCreateFunctions checks if the functions in the request are already
        /// known and returns the known function (including its ID) if so. If a
        /// function does not already exist, it is written to the backing metastore.
        async fn get_or_create_functions(
            &self,
            request: tonic::Request<super::GetOrCreateFunctionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetOrCreateFunctionsResponse>,
            tonic::Status,
        >;
        /// GetOrCreateLocations checks if the locations in the request are already
        /// known and returns the known location (including its ID) if so. If a
        /// location does not already exist, it is written to the backing metastore.
        async fn get_or_create_locations(
            &self,
            request: tonic::Request<super::GetOrCreateLocationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetOrCreateLocationsResponse>,
            tonic::Status,
        >;
        /// GetOrCreateStacktraces checks if the stacktraces in the request are
        /// already known and returns the known stacktrace (including its ID) if so.
        /// If a stacktrace does not already exist, it is written to the backing
        /// metastore.
        async fn get_or_create_stacktraces(
            &self,
            request: tonic::Request<super::GetOrCreateStacktracesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetOrCreateStacktracesResponse>,
            tonic::Status,
        >;
        /// UnsymbolizedLocations returns locations that can be symbolized but haven't
        /// been asynchronously symbolized yet.
        async fn unsymbolized_locations(
            &self,
            request: tonic::Request<super::UnsymbolizedLocationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnsymbolizedLocationsResponse>,
            tonic::Status,
        >;
        /// CreateLocationLines creates the location lines contained in the provided
        /// locations.
        async fn create_location_lines(
            &self,
            request: tonic::Request<super::CreateLocationLinesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateLocationLinesResponse>,
            tonic::Status,
        >;
        /// Locations retrieves locations.
        async fn locations(
            &self,
            request: tonic::Request<super::LocationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LocationsResponse>,
            tonic::Status,
        >;
        /// Functions retrieves functions.
        async fn functions(
            &self,
            request: tonic::Request<super::FunctionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FunctionsResponse>,
            tonic::Status,
        >;
        /// Mappings retrieves mappings.
        async fn mappings(
            &self,
            request: tonic::Request<super::MappingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MappingsResponse>,
            tonic::Status,
        >;
        /// Stacktraces retrieves mappings.
        async fn stacktraces(
            &self,
            request: tonic::Request<super::StacktracesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StacktracesResponse>,
            tonic::Status,
        >;
    }
    /// MetastoreService
    #[derive(Debug)]
    pub struct MetastoreServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> MetastoreServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for MetastoreServiceServer<T>
    where
        T: MetastoreService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/parca.metastore.v1alpha1.MetastoreService/GetOrCreateMappings" => {
                    #[allow(non_camel_case_types)]
                    struct GetOrCreateMappingsSvc<T: MetastoreService>(pub Arc<T>);
                    impl<
                        T: MetastoreService,
                    > tonic::server::UnaryService<super::GetOrCreateMappingsRequest>
                    for GetOrCreateMappingsSvc<T> {
                        type Response = super::GetOrCreateMappingsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetOrCreateMappingsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetastoreService>::get_or_create_mappings(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOrCreateMappingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/parca.metastore.v1alpha1.MetastoreService/GetOrCreateFunctions" => {
                    #[allow(non_camel_case_types)]
                    struct GetOrCreateFunctionsSvc<T: MetastoreService>(pub Arc<T>);
                    impl<
                        T: MetastoreService,
                    > tonic::server::UnaryService<super::GetOrCreateFunctionsRequest>
                    for GetOrCreateFunctionsSvc<T> {
                        type Response = super::GetOrCreateFunctionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetOrCreateFunctionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetastoreService>::get_or_create_functions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOrCreateFunctionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/parca.metastore.v1alpha1.MetastoreService/GetOrCreateLocations" => {
                    #[allow(non_camel_case_types)]
                    struct GetOrCreateLocationsSvc<T: MetastoreService>(pub Arc<T>);
                    impl<
                        T: MetastoreService,
                    > tonic::server::UnaryService<super::GetOrCreateLocationsRequest>
                    for GetOrCreateLocationsSvc<T> {
                        type Response = super::GetOrCreateLocationsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetOrCreateLocationsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetastoreService>::get_or_create_locations(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOrCreateLocationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/parca.metastore.v1alpha1.MetastoreService/GetOrCreateStacktraces" => {
                    #[allow(non_camel_case_types)]
                    struct GetOrCreateStacktracesSvc<T: MetastoreService>(pub Arc<T>);
                    impl<
                        T: MetastoreService,
                    > tonic::server::UnaryService<super::GetOrCreateStacktracesRequest>
                    for GetOrCreateStacktracesSvc<T> {
                        type Response = super::GetOrCreateStacktracesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetOrCreateStacktracesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetastoreService>::get_or_create_stacktraces(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOrCreateStacktracesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/parca.metastore.v1alpha1.MetastoreService/UnsymbolizedLocations" => {
                    #[allow(non_camel_case_types)]
                    struct UnsymbolizedLocationsSvc<T: MetastoreService>(pub Arc<T>);
                    impl<
                        T: MetastoreService,
                    > tonic::server::UnaryService<super::UnsymbolizedLocationsRequest>
                    for UnsymbolizedLocationsSvc<T> {
                        type Response = super::UnsymbolizedLocationsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UnsymbolizedLocationsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetastoreService>::unsymbolized_locations(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnsymbolizedLocationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/parca.metastore.v1alpha1.MetastoreService/CreateLocationLines" => {
                    #[allow(non_camel_case_types)]
                    struct CreateLocationLinesSvc<T: MetastoreService>(pub Arc<T>);
                    impl<
                        T: MetastoreService,
                    > tonic::server::UnaryService<super::CreateLocationLinesRequest>
                    for CreateLocationLinesSvc<T> {
                        type Response = super::CreateLocationLinesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateLocationLinesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetastoreService>::create_location_lines(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateLocationLinesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/parca.metastore.v1alpha1.MetastoreService/Locations" => {
                    #[allow(non_camel_case_types)]
                    struct LocationsSvc<T: MetastoreService>(pub Arc<T>);
                    impl<
                        T: MetastoreService,
                    > tonic::server::UnaryService<super::LocationsRequest>
                    for LocationsSvc<T> {
                        type Response = super::LocationsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LocationsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetastoreService>::locations(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LocationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/parca.metastore.v1alpha1.MetastoreService/Functions" => {
                    #[allow(non_camel_case_types)]
                    struct FunctionsSvc<T: MetastoreService>(pub Arc<T>);
                    impl<
                        T: MetastoreService,
                    > tonic::server::UnaryService<super::FunctionsRequest>
                    for FunctionsSvc<T> {
                        type Response = super::FunctionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FunctionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetastoreService>::functions(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FunctionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/parca.metastore.v1alpha1.MetastoreService/Mappings" => {
                    #[allow(non_camel_case_types)]
                    struct MappingsSvc<T: MetastoreService>(pub Arc<T>);
                    impl<
                        T: MetastoreService,
                    > tonic::server::UnaryService<super::MappingsRequest>
                    for MappingsSvc<T> {
                        type Response = super::MappingsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MappingsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetastoreService>::mappings(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MappingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/parca.metastore.v1alpha1.MetastoreService/Stacktraces" => {
                    #[allow(non_camel_case_types)]
                    struct StacktracesSvc<T: MetastoreService>(pub Arc<T>);
                    impl<
                        T: MetastoreService,
                    > tonic::server::UnaryService<super::StacktracesRequest>
                    for StacktracesSvc<T> {
                        type Response = super::StacktracesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StacktracesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetastoreService>::stacktraces(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StacktracesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for MetastoreServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "parca.metastore.v1alpha1.MetastoreService";
    impl<T> tonic::server::NamedService for MetastoreServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
