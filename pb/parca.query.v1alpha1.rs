// This file is @generated by prost-build.
/// ProfileTypesRequest is the request to retrieve the list of available profile types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProfileTypesRequest {}
/// ProfileTypesResponse is the response to retrieve the list of available profile types.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProfileTypesResponse {
    /// types is the list of available profile types.
    #[prost(message, repeated, tag = "1")]
    pub types: ::prost::alloc::vec::Vec<ProfileType>,
}
/// ProfileType is the type of a profile as well as the units the profile type is available in.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProfileType {
    /// name is the name of the profile type.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// sample_type is the type of the samples in the profile.
    #[prost(string, tag = "2")]
    pub sample_type: ::prost::alloc::string::String,
    /// sample_unit is the unit of the samples in the profile.
    #[prost(string, tag = "3")]
    pub sample_unit: ::prost::alloc::string::String,
    /// period_type is the type of the periods in the profile.
    #[prost(string, tag = "4")]
    pub period_type: ::prost::alloc::string::String,
    /// period_unit is the unit of the periods in the profile.
    #[prost(string, tag = "5")]
    pub period_unit: ::prost::alloc::string::String,
    /// delta describes whether the profile is a delta profile.
    #[prost(bool, tag = "6")]
    pub delta: bool,
}
/// QueryRangeRequest is the request for a set of profiles matching a query over a time window
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRangeRequest {
    /// query is the query string to match profiles against
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    /// start is the start of the query time window
    #[prost(message, optional, tag = "2")]
    pub start: ::core::option::Option<::prost_types::Timestamp>,
    /// end is the end of the query time window
    #[prost(message, optional, tag = "3")]
    pub end: ::core::option::Option<::prost_types::Timestamp>,
    /// limit is the max number of profiles to include in the response
    #[prost(uint32, tag = "4")]
    pub limit: u32,
    /// step is the duration of each sample returned.
    #[prost(message, optional, tag = "5")]
    pub step: ::core::option::Option<::prost_types::Duration>,
    /// sum_by is the set of labels to sum by
    #[prost(string, repeated, tag = "6")]
    pub sum_by: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// QueryRangeResponse is the set of matching profile values
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRangeResponse {
    /// series is the set of metrics series that satisfy the query range request
    #[prost(message, repeated, tag = "1")]
    pub series: ::prost::alloc::vec::Vec<MetricsSeries>,
}
/// MetricsSeries is a set of labels and corresponding sample values
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricsSeries {
    /// labelset is the set of key value pairs
    #[prost(message, optional, tag = "1")]
    pub labelset: ::core::option::Option<super::super::profilestore::v1alpha1::LabelSet>,
    /// samples is the set of top-level cumulative values of the corresponding profiles
    #[prost(message, repeated, tag = "2")]
    pub samples: ::prost::alloc::vec::Vec<MetricsSample>,
    /// period_type is the value type of profile period
    #[prost(message, optional, tag = "3")]
    pub period_type: ::core::option::Option<ValueType>,
    /// sample_type is the value type of profile sample
    #[prost(message, optional, tag = "4")]
    pub sample_type: ::core::option::Option<ValueType>,
}
/// MetricsSample is a cumulative value and timestamp of a profile
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MetricsSample {
    /// timestamp is the time the profile was ingested
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// value is the cumulative value for the profile
    #[prost(int64, tag = "2")]
    pub value: i64,
    /// value_per_second is the calculated per second average in the steps duration
    #[prost(double, tag = "3")]
    pub value_per_second: f64,
    /// duration is the normalized aggregated duration the metric samples has been observed over.
    #[prost(int64, tag = "4")]
    pub duration: i64,
}
/// MergeProfile contains parameters for a merge request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeProfile {
    /// query is the query string to match profiles for merge
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    /// start is the beginning of the evaluation time window
    #[prost(message, optional, tag = "2")]
    pub start: ::core::option::Option<::prost_types::Timestamp>,
    /// end is the end of the evaluation time window
    #[prost(message, optional, tag = "3")]
    pub end: ::core::option::Option<::prost_types::Timestamp>,
}
/// SingleProfile contains parameters for a single profile query request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SingleProfile {
    /// time is the point in time to perform the profile request
    #[prost(message, optional, tag = "1")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    /// query is the query string to retrieve the profile
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
}
/// DiffProfile contains parameters for a profile diff request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiffProfile {
    /// a is the first profile to diff
    #[prost(message, optional, tag = "1")]
    pub a: ::core::option::Option<ProfileDiffSelection>,
    /// b is the second profile to diff
    #[prost(message, optional, tag = "2")]
    pub b: ::core::option::Option<ProfileDiffSelection>,
    /// absolute diffing, by default comparisons are relative
    #[prost(bool, optional, tag = "3")]
    pub absolute: ::core::option::Option<bool>,
}
/// ProfileDiffSelection contains the parameters of a diff selection
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProfileDiffSelection {
    /// mode is the selection of the diff mode
    #[prost(enumeration = "profile_diff_selection::Mode", tag = "1")]
    pub mode: i32,
    /// options are the available options for a diff selection
    #[prost(oneof = "profile_diff_selection::Options", tags = "2, 3")]
    pub options: ::core::option::Option<profile_diff_selection::Options>,
}
/// Nested message and enum types in `ProfileDiffSelection`.
pub mod profile_diff_selection {
    /// Mode specifies the type of diff
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        /// MODE_SINGLE_UNSPECIFIED default unspecified
        SingleUnspecified = 0,
        /// MODE_MERGE merge profile
        Merge = 1,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::SingleUnspecified => "MODE_SINGLE_UNSPECIFIED",
                Self::Merge => "MODE_MERGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_SINGLE_UNSPECIFIED" => Some(Self::SingleUnspecified),
                "MODE_MERGE" => Some(Self::Merge),
                _ => None,
            }
        }
    }
    /// options are the available options for a diff selection
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Options {
        /// merge contains options for a merge request
        #[prost(message, tag = "2")]
        Merge(super::MergeProfile),
        /// single contains options for a single profile request
        #[prost(message, tag = "3")]
        Single(super::SingleProfile),
    }
}
/// QueryRequest is a request for a profile query
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRequest {
    /// mode indicates the type of query performed
    #[prost(enumeration = "query_request::Mode", tag = "1")]
    pub mode: i32,
    /// report_type is the type of report to return
    #[prost(enumeration = "query_request::ReportType", tag = "5")]
    pub report_type: i32,
    /// filter_query is the query string to filter the profile samples
    #[deprecated]
    #[prost(string, optional, tag = "6")]
    pub filter_query: ::core::option::Option<::prost::alloc::string::String>,
    /// node_trim_threshold is the threshold % where the nodes with Value less than this will be removed from the report
    #[prost(float, optional, tag = "7")]
    pub node_trim_threshold: ::core::option::Option<f32>,
    /// group_by indicates the fields to group by
    #[prost(message, optional, tag = "8")]
    pub group_by: ::core::option::Option<GroupBy>,
    /// source information about the source requested, required if source report is requested
    #[prost(message, optional, tag = "9")]
    pub source_reference: ::core::option::Option<SourceReference>,
    /// which runtime frames to filter out, often interpreter frames like python or ruby are not super useful by default
    #[deprecated]
    #[prost(message, optional, tag = "10")]
    pub runtime_filter: ::core::option::Option<RuntimeFilter>,
    /// invert_call_stack inverts the call stacks in the flamegraph
    #[prost(bool, optional, tag = "11")]
    pub invert_call_stack: ::core::option::Option<bool>,
    /// a set of filter to apply to the query request
    #[prost(message, repeated, tag = "12")]
    pub filter: ::prost::alloc::vec::Vec<Filter>,
    /// options are the options corresponding to the mode
    #[prost(oneof = "query_request::Options", tags = "2, 3, 4")]
    pub options: ::core::option::Option<query_request::Options>,
}
/// Nested message and enum types in `QueryRequest`.
pub mod query_request {
    /// Mode is the type of query request
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        /// MODE_SINGLE_UNSPECIFIED query unspecified
        SingleUnspecified = 0,
        /// MODE_DIFF is a diff query
        Diff = 1,
        /// MODE_MERGE is a merge query
        Merge = 2,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::SingleUnspecified => "MODE_SINGLE_UNSPECIFIED",
                Self::Diff => "MODE_DIFF",
                Self::Merge => "MODE_MERGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_SINGLE_UNSPECIFIED" => Some(Self::SingleUnspecified),
                "MODE_DIFF" => Some(Self::Diff),
                "MODE_MERGE" => Some(Self::Merge),
                _ => None,
            }
        }
    }
    /// ReportType is the type of report to return
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReportType {
        /// REPORT_TYPE_FLAMEGRAPH_UNSPECIFIED unspecified
        FlamegraphUnspecified = 0,
        /// REPORT_TYPE_PPROF unspecified
        Pprof = 1,
        /// REPORT_TYPE_TOP unspecified
        Top = 2,
        /// REPORT_TYPE_CALLGRAPH unspecified
        Callgraph = 3,
        /// REPORT_TYPE_FLAMEGRAPH_TABLE unspecified
        FlamegraphTable = 4,
        /// REPORT_TYPE_FLAMEGRAPH_ARROW unspecified
        FlamegraphArrow = 5,
        /// REPORT_TYPE_SOURCE contains source code annotated with profiling information
        Source = 6,
        /// REPORT_TYPE_TABLE_ARROW unspecified
        TableArrow = 7,
        /// REPORT_TYPE_PROFILE_METADATA contains metadata about the profile i.e. binaries, labels
        ProfileMetadata = 8,
    }
    impl ReportType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::FlamegraphUnspecified => "REPORT_TYPE_FLAMEGRAPH_UNSPECIFIED",
                Self::Pprof => "REPORT_TYPE_PPROF",
                Self::Top => "REPORT_TYPE_TOP",
                Self::Callgraph => "REPORT_TYPE_CALLGRAPH",
                Self::FlamegraphTable => "REPORT_TYPE_FLAMEGRAPH_TABLE",
                Self::FlamegraphArrow => "REPORT_TYPE_FLAMEGRAPH_ARROW",
                Self::Source => "REPORT_TYPE_SOURCE",
                Self::TableArrow => "REPORT_TYPE_TABLE_ARROW",
                Self::ProfileMetadata => "REPORT_TYPE_PROFILE_METADATA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REPORT_TYPE_FLAMEGRAPH_UNSPECIFIED" => Some(Self::FlamegraphUnspecified),
                "REPORT_TYPE_PPROF" => Some(Self::Pprof),
                "REPORT_TYPE_TOP" => Some(Self::Top),
                "REPORT_TYPE_CALLGRAPH" => Some(Self::Callgraph),
                "REPORT_TYPE_FLAMEGRAPH_TABLE" => Some(Self::FlamegraphTable),
                "REPORT_TYPE_FLAMEGRAPH_ARROW" => Some(Self::FlamegraphArrow),
                "REPORT_TYPE_SOURCE" => Some(Self::Source),
                "REPORT_TYPE_TABLE_ARROW" => Some(Self::TableArrow),
                "REPORT_TYPE_PROFILE_METADATA" => Some(Self::ProfileMetadata),
                _ => None,
            }
        }
    }
    /// options are the options corresponding to the mode
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Options {
        /// diff contains the diff query options
        #[prost(message, tag = "2")]
        Diff(super::DiffProfile),
        /// merge contains the merge query options
        #[prost(message, tag = "3")]
        Merge(super::MergeProfile),
        /// single contains the single query options
        #[prost(message, tag = "4")]
        Single(super::SingleProfile),
    }
}
/// Filter to apply to the query request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Filter {
    /// filter is a oneof type of filter to apply to the query request
    #[prost(oneof = "filter::Filter", tags = "1, 2")]
    pub filter: ::core::option::Option<filter::Filter>,
}
/// Nested message and enum types in `Filter`.
pub mod filter {
    /// filter is a oneof type of filter to apply to the query request
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Filter {
        /// stack_filter is a filter for filtering by stacks
        #[prost(message, tag = "1")]
        StackFilter(super::StackFilter),
        /// frame_filter is a filter for filtering by frames
        #[prost(message, tag = "2")]
        FrameFilter(super::FrameFilter),
    }
}
/// StackFilter is a filter for filtering by stacks
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StackFilter {
    /// filter contains the different methods in which you can filter a stack
    #[prost(oneof = "stack_filter::Filter", tags = "1")]
    pub filter: ::core::option::Option<stack_filter::Filter>,
}
/// Nested message and enum types in `StackFilter`.
pub mod stack_filter {
    /// filter contains the different methods in which you can filter a stack
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Filter {
        /// function_name_stack_filter is the function name to filter by
        #[prost(message, tag = "1")]
        FunctionNameStackFilter(super::FunctionNameStackFilter),
    }
}
/// FunctionNameStackFilter is a filter for filtering by function name
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionNameStackFilter {
    /// function_to_filter is the function name to filter by
    #[prost(string, tag = "1")]
    pub function_to_filter: ::prost::alloc::string::String,
}
/// FrameFilter is a filter for filtering by frames
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrameFilter {
    /// filter contains the different methods in which you can filter a frame
    #[prost(oneof = "frame_filter::Filter", tags = "1")]
    pub filter: ::core::option::Option<frame_filter::Filter>,
}
/// Nested message and enum types in `FrameFilter`.
pub mod frame_filter {
    /// filter contains the different methods in which you can filter a frame
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Filter {
        /// binary_frame_filter is the list of binary names to filter by
        #[prost(message, tag = "1")]
        BinaryFrameFilter(super::BinaryFrameFilter),
    }
}
/// BinaryFrameFilter is a filter for filtering by binaries
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BinaryFrameFilter {
    /// include_binaries is the list of binaries to filter by
    #[prost(string, repeated, tag = "1")]
    pub include_binaries: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// RuntimeFilter configures which runtimes to filter frames out for.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RuntimeFilter {
    /// Whether to show frames of the python runtime.
    #[prost(bool, tag = "1")]
    pub show_python: bool,
    /// Whether to show frames of the ruby runtime.
    #[prost(bool, tag = "2")]
    pub show_ruby: bool,
    /// Whether to only show interpreted frames.
    #[prost(bool, tag = "3")]
    pub show_interpreted_only: bool,
}
/// SourceReference contains a reference to source code.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceReference {
    /// The build ID to request the source of.
    #[prost(string, tag = "1")]
    pub build_id: ::prost::alloc::string::String,
    /// The filename requested.
    #[prost(string, tag = "2")]
    pub filename: ::prost::alloc::string::String,
    /// Whether to perform a full query or just retrieve the source.
    #[prost(bool, tag = "3")]
    pub source_only: bool,
}
/// GroupBy encapsulates the repeated fields to group by
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupBy {
    /// the names of the fields to group by.
    /// special fields are the ones prefixed with "labels." which are grouping by pprof labels.
    #[prost(string, repeated, tag = "1")]
    pub fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Top is the top report type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Top {
    /// list are the list of ordered elements of the table
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<TopNode>,
    /// reported is the number of lines reported
    #[prost(int32, tag = "2")]
    pub reported: i32,
    /// total is the number of lines that exist in the report
    /// Use total from the top level query response instead.
    #[deprecated]
    #[prost(int32, tag = "3")]
    pub total: i32,
    /// unit is the unit represented by top table
    #[prost(string, tag = "4")]
    pub unit: ::prost::alloc::string::String,
}
/// TopNode is a node entry in a top list
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopNode {
    /// meta is the metadata about the node
    #[prost(message, optional, tag = "1")]
    pub meta: ::core::option::Option<TopNodeMeta>,
    /// cumulative is the cumulative value of the node
    #[prost(int64, tag = "2")]
    pub cumulative: i64,
    /// flat is the flat value of the node
    #[prost(int64, tag = "3")]
    pub flat: i64,
    /// diff is the diff value between two profiles
    #[prost(int64, tag = "4")]
    pub diff: i64,
}
/// TopNodeMeta is the metadata for a given node
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopNodeMeta {
    /// location is the location for the code
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<super::super::metastore::v1alpha1::Location>,
    /// mapping is the mapping into code
    #[prost(message, optional, tag = "2")]
    pub mapping: ::core::option::Option<super::super::metastore::v1alpha1::Mapping>,
    /// function is the function information
    #[prost(message, optional, tag = "3")]
    pub function: ::core::option::Option<super::super::metastore::v1alpha1::Function>,
    /// line is the line location
    #[prost(message, optional, tag = "4")]
    pub line: ::core::option::Option<super::super::metastore::v1alpha1::Line>,
}
/// Flamegraph is the flame graph report type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Flamegraph {
    /// root is the root of the flame graph
    #[prost(message, optional, tag = "1")]
    pub root: ::core::option::Option<FlamegraphRootNode>,
    /// total is the total weight of the flame graph
    /// Use total from the top level query response instead.
    #[deprecated]
    #[prost(int64, tag = "2")]
    pub total: i64,
    /// unit is the unit represented by the flame graph
    #[prost(string, tag = "3")]
    pub unit: ::prost::alloc::string::String,
    /// height is the max height of the graph
    #[prost(int32, tag = "4")]
    pub height: i32,
    /// string_table holds all deduplicated strings used in the meta data.
    #[prost(string, repeated, tag = "5")]
    pub string_table: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// locations deduplicated by their ID to be referenced by nodes.
    #[prost(message, repeated, tag = "6")]
    pub locations: ::prost::alloc::vec::Vec<super::super::metastore::v1alpha1::Location>,
    /// mapping deduplicated by their ID to be referenced by nodes.
    #[prost(message, repeated, tag = "7")]
    pub mapping: ::prost::alloc::vec::Vec<super::super::metastore::v1alpha1::Mapping>,
    /// function deduplicated by their ID to be referenced by nodes.
    #[prost(message, repeated, tag = "8")]
    pub function: ::prost::alloc::vec::Vec<super::super::metastore::v1alpha1::Function>,
    /// untrimmed_total is the total weight of the flame graph before trimming.
    /// Use trimmed instead.
    #[deprecated]
    #[prost(int64, tag = "9")]
    pub untrimmed_total: i64,
    /// trimmed is the amount of cumulative value trimmed from the flame graph.
    #[prost(int64, tag = "10")]
    pub trimmed: i64,
}
/// Flamegraph is the flame graph report type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlamegraphArrow {
    /// record is the arrow record containing the actual flamegraph data
    #[prost(bytes = "vec", tag = "1")]
    pub record: ::prost::alloc::vec::Vec<u8>,
    /// unit is the unit represented by the flame graph
    #[prost(string, tag = "2")]
    pub unit: ::prost::alloc::string::String,
    /// height is the max height of the graph
    #[prost(int32, tag = "3")]
    pub height: i32,
    /// trimmed is the amount of cumulative value trimmed from the flame graph.
    #[prost(int64, tag = "4")]
    pub trimmed: i64,
}
/// Source is the result of the source report type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Source {
    /// An arrow record that contains a row per source code line with value and diff columns for flat and cumulative.
    #[prost(bytes = "vec", tag = "1")]
    pub record: ::prost::alloc::vec::Vec<u8>,
    /// The actual source file content.
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
    /// The unit of the values in the record.
    #[prost(string, tag = "3")]
    pub unit: ::prost::alloc::string::String,
}
/// FlamegraphRootNode is a root node of a flame graph
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlamegraphRootNode {
    /// cumulative is the cumulative value of the graph
    #[prost(int64, tag = "1")]
    pub cumulative: i64,
    /// diff is the diff
    #[prost(int64, tag = "2")]
    pub diff: i64,
    /// children are the list of the children of the root node
    #[prost(message, repeated, tag = "3")]
    pub children: ::prost::alloc::vec::Vec<FlamegraphNode>,
}
/// FlamegraphNode represents a node in the graph
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlamegraphNode {
    /// meta is the metadata about the node
    #[prost(message, optional, tag = "1")]
    pub meta: ::core::option::Option<FlamegraphNodeMeta>,
    /// cumulative is the cumulative value of the node
    #[prost(int64, tag = "2")]
    pub cumulative: i64,
    /// diff is the diff
    #[prost(int64, tag = "3")]
    pub diff: i64,
    /// children are the child nodes
    #[prost(message, repeated, tag = "4")]
    pub children: ::prost::alloc::vec::Vec<FlamegraphNode>,
}
/// FlamegraphNodeMeta is the metadata for a given node
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlamegraphNodeMeta {
    /// location is the location for the code
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<super::super::metastore::v1alpha1::Location>,
    /// mapping is the mapping into code
    #[prost(message, optional, tag = "2")]
    pub mapping: ::core::option::Option<super::super::metastore::v1alpha1::Mapping>,
    /// function is the function information
    #[prost(message, optional, tag = "3")]
    pub function: ::core::option::Option<super::super::metastore::v1alpha1::Function>,
    /// line is the line location
    #[prost(message, optional, tag = "4")]
    pub line: ::core::option::Option<super::super::metastore::v1alpha1::Line>,
    /// location_index has the index to the deduplicated location in the location table.
    #[prost(uint32, tag = "5")]
    pub location_index: u32,
    /// line_index is the line index within the referenced location.
    #[prost(uint32, tag = "6")]
    pub line_index: u32,
}
/// CallgraphNode represents a node in the graph
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallgraphNode {
    /// id is the unique id of the node
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// meta is the metadata about the node
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<CallgraphNodeMeta>,
    /// cumulative is the cumulative value of the node
    #[prost(int64, tag = "3")]
    pub cumulative: i64,
    /// flat is the flat value of the node
    #[prost(int64, tag = "4")]
    pub flat: i64,
}
/// TopNodeMeta is the metadata for a given node
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallgraphNodeMeta {
    /// location is the location for the code
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<super::super::metastore::v1alpha1::Location>,
    /// mapping is the mapping into code
    #[prost(message, optional, tag = "2")]
    pub mapping: ::core::option::Option<super::super::metastore::v1alpha1::Mapping>,
    /// function is the function information
    #[prost(message, optional, tag = "3")]
    pub function: ::core::option::Option<super::super::metastore::v1alpha1::Function>,
    /// line is the line location
    #[prost(message, optional, tag = "4")]
    pub line: ::core::option::Option<super::super::metastore::v1alpha1::Line>,
}
/// CallgraphEdge represents an edge in the graph
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallgraphEdge {
    /// id is the unique id of the edge
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// source represents the id of the source node
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
    /// target represents the id of the target node
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// cumulative is the cumulative value of the edge
    #[prost(int64, tag = "4")]
    pub cumulative: i64,
    /// is_collapsed indicates if the edge is collapsed
    #[prost(bool, tag = "5")]
    pub is_collapsed: bool,
}
/// Callgraph is the callgraph report type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Callgraph {
    /// nodes are the nodes in the callgraph
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<CallgraphNode>,
    /// edges are the edges connecting nodes in the callgraph
    #[prost(message, repeated, tag = "2")]
    pub edges: ::prost::alloc::vec::Vec<CallgraphEdge>,
    /// cumulative is the total cumulative value of the callgraph
    /// Use total from the top level query response instead.
    #[deprecated]
    #[prost(int64, tag = "3")]
    pub cumulative: i64,
}
/// QueryResponse is the returned report for the given query
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResponse {
    /// total is the total number of samples shown in the report.
    #[prost(int64, tag = "9")]
    pub total: i64,
    /// filtered is the number of samples filtered out of the report.
    #[prost(int64, tag = "10")]
    pub filtered: i64,
    /// report is the generated report
    #[prost(oneof = "query_response::Report", tags = "5, 6, 7, 8, 11, 12, 13, 14")]
    pub report: ::core::option::Option<query_response::Report>,
}
/// Nested message and enum types in `QueryResponse`.
pub mod query_response {
    /// report is the generated report
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Report {
        /// flamegraph is a flamegraph representation of the report
        #[prost(message, tag = "5")]
        Flamegraph(super::Flamegraph),
        /// pprof is a pprof profile as compressed bytes
        #[prost(bytes, tag = "6")]
        Pprof(::prost::alloc::vec::Vec<u8>),
        /// top is a top list representation of the report
        #[prost(message, tag = "7")]
        Top(super::Top),
        /// callgraph is a callgraph nodes and edges representation of the report
        #[prost(message, tag = "8")]
        Callgraph(super::Callgraph),
        /// flamegraph_arrow is a flamegraph encoded as a arrow record
        #[prost(message, tag = "11")]
        FlamegraphArrow(super::FlamegraphArrow),
        /// source is the source report type result
        #[prost(message, tag = "12")]
        Source(super::Source),
        /// table_arrow is a table encoded as a arrow record
        #[prost(message, tag = "13")]
        TableArrow(super::TableArrow),
        /// profile_metadata contains metadata about the profile i.e. binaries, labels
        #[prost(message, tag = "14")]
        ProfileMetadata(super::ProfileMetadata),
    }
}
/// SeriesRequest is unimplemented
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeriesRequest {
    /// match ...
    #[prost(string, repeated, tag = "1")]
    pub r#match: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// start ...
    #[prost(message, optional, tag = "2")]
    pub start: ::core::option::Option<::prost_types::Timestamp>,
    /// end ...
    #[prost(message, optional, tag = "3")]
    pub end: ::core::option::Option<::prost_types::Timestamp>,
}
/// SeriesResponse is unimplemented
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeriesResponse {}
/// LabelsRequest are the request values for labels
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelsRequest {
    /// match are the set of matching strings
    #[prost(string, repeated, tag = "1")]
    pub r#match: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// start is the start of the time window to perform the query
    #[prost(message, optional, tag = "2")]
    pub start: ::core::option::Option<::prost_types::Timestamp>,
    /// end is the end of the time window to perform the query
    #[prost(message, optional, tag = "3")]
    pub end: ::core::option::Option<::prost_types::Timestamp>,
    /// profile_type is the type of profile to filter by
    #[prost(string, optional, tag = "4")]
    pub profile_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// LabelsResponse is the set of matching label names
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelsResponse {
    /// / label_names are the set of matching label names
    #[prost(string, repeated, tag = "1")]
    pub label_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// warnings is unimplemented
    #[prost(string, repeated, tag = "2")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// ValuesRequest are the request values for a values request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValuesRequest {
    /// label_name is the label name to match values against
    #[prost(string, tag = "1")]
    pub label_name: ::prost::alloc::string::String,
    /// match are the set of matching strings to match values against
    #[prost(string, repeated, tag = "2")]
    pub r#match: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// start is the start of the time window to perform the query
    #[prost(message, optional, tag = "3")]
    pub start: ::core::option::Option<::prost_types::Timestamp>,
    /// end is the end of the time window to perform the query
    #[prost(message, optional, tag = "4")]
    pub end: ::core::option::Option<::prost_types::Timestamp>,
    /// profile_type is the type of profile to filter by
    #[prost(string, optional, tag = "5")]
    pub profile_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// ValuesResponse are the set of matching values
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValuesResponse {
    /// label_values are the set of matching label values
    #[prost(string, repeated, tag = "1")]
    pub label_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// warnings is unimplemented
    #[prost(string, repeated, tag = "2")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// ValueType represents a value, including its type and unit
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValueType {
    /// type is the type of the value
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// unit is the unit of the value
    #[prost(string, tag = "2")]
    pub unit: ::prost::alloc::string::String,
}
/// ShareProfileRequest represents the query denoting the profile and a description about the profile
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareProfileRequest {
    /// QueryRequest that refers to the profile to be shared
    #[prost(message, optional, tag = "1")]
    pub query_request: ::core::option::Option<QueryRequest>,
    /// description about the profile
    #[prost(string, optional, tag = "2")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
/// ShareProfileResponse represents the shared link of a profile
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareProfileResponse {
    /// link to access the profile
    #[prost(string, tag = "1")]
    pub link: ::prost::alloc::string::String,
}
/// TableArrow has the table encoded as a arrow record
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableArrow {
    /// record is the arrow record containing the actual table data
    #[prost(bytes = "vec", tag = "1")]
    pub record: ::prost::alloc::vec::Vec<u8>,
    /// unit is the unit represented by the flame graph
    #[prost(string, tag = "2")]
    pub unit: ::prost::alloc::string::String,
}
/// ProfileMetadata contains metadata about the profile i.e. binaries, labels
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProfileMetadata {
    /// mapping_files is the list of binaries in the profile
    #[prost(string, repeated, tag = "1")]
    pub mapping_files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// labels is the list of labels in the profile
    #[prost(string, repeated, tag = "2")]
    pub labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Generated server implementations.
pub mod query_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with QueryServiceServer.
    #[async_trait]
    pub trait QueryService: std::marker::Send + std::marker::Sync + 'static {
        /// QueryRange performs a profile query over a time range
        async fn query_range(
            &self,
            request: tonic::Request<super::QueryRangeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryRangeResponse>,
            tonic::Status,
        >;
        /// Query performs a profile query
        async fn query(
            &self,
            request: tonic::Request<super::QueryRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryResponse>, tonic::Status>;
        /// Series is unimplemented
        async fn series(
            &self,
            request: tonic::Request<super::SeriesRequest>,
        ) -> std::result::Result<tonic::Response<super::SeriesResponse>, tonic::Status>;
        /// ProfileTypes returns the list of available profile types.
        async fn profile_types(
            &self,
            request: tonic::Request<super::ProfileTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ProfileTypesResponse>,
            tonic::Status,
        >;
        /// Labels returns the set of label names against a given matching string and time frame
        async fn labels(
            &self,
            request: tonic::Request<super::LabelsRequest>,
        ) -> std::result::Result<tonic::Response<super::LabelsResponse>, tonic::Status>;
        /// Values returns the set of values that match a given label and time frame
        async fn values(
            &self,
            request: tonic::Request<super::ValuesRequest>,
        ) -> std::result::Result<tonic::Response<super::ValuesResponse>, tonic::Status>;
        /// ShareProfile uploads the given profile to pprof.me and returns a link to the profile.
        async fn share_profile(
            &self,
            request: tonic::Request<super::ShareProfileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ShareProfileResponse>,
            tonic::Status,
        >;
    }
    /// QueryService is the service that provides APIs to retrieve and inspect profiles
    #[derive(Debug)]
    pub struct QueryServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> QueryServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for QueryServiceServer<T>
    where
        T: QueryService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/parca.query.v1alpha1.QueryService/QueryRange" => {
                    #[allow(non_camel_case_types)]
                    struct QueryRangeSvc<T: QueryService>(pub Arc<T>);
                    impl<
                        T: QueryService,
                    > tonic::server::UnaryService<super::QueryRangeRequest>
                    for QueryRangeSvc<T> {
                        type Response = super::QueryRangeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryRangeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as QueryService>::query_range(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryRangeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/parca.query.v1alpha1.QueryService/Query" => {
                    #[allow(non_camel_case_types)]
                    struct QuerySvc<T: QueryService>(pub Arc<T>);
                    impl<
                        T: QueryService,
                    > tonic::server::UnaryService<super::QueryRequest> for QuerySvc<T> {
                        type Response = super::QueryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as QueryService>::query(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QuerySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/parca.query.v1alpha1.QueryService/Series" => {
                    #[allow(non_camel_case_types)]
                    struct SeriesSvc<T: QueryService>(pub Arc<T>);
                    impl<
                        T: QueryService,
                    > tonic::server::UnaryService<super::SeriesRequest>
                    for SeriesSvc<T> {
                        type Response = super::SeriesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SeriesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as QueryService>::series(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SeriesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/parca.query.v1alpha1.QueryService/ProfileTypes" => {
                    #[allow(non_camel_case_types)]
                    struct ProfileTypesSvc<T: QueryService>(pub Arc<T>);
                    impl<
                        T: QueryService,
                    > tonic::server::UnaryService<super::ProfileTypesRequest>
                    for ProfileTypesSvc<T> {
                        type Response = super::ProfileTypesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ProfileTypesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as QueryService>::profile_types(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ProfileTypesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/parca.query.v1alpha1.QueryService/Labels" => {
                    #[allow(non_camel_case_types)]
                    struct LabelsSvc<T: QueryService>(pub Arc<T>);
                    impl<
                        T: QueryService,
                    > tonic::server::UnaryService<super::LabelsRequest>
                    for LabelsSvc<T> {
                        type Response = super::LabelsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LabelsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as QueryService>::labels(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LabelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/parca.query.v1alpha1.QueryService/Values" => {
                    #[allow(non_camel_case_types)]
                    struct ValuesSvc<T: QueryService>(pub Arc<T>);
                    impl<
                        T: QueryService,
                    > tonic::server::UnaryService<super::ValuesRequest>
                    for ValuesSvc<T> {
                        type Response = super::ValuesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ValuesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as QueryService>::values(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValuesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/parca.query.v1alpha1.QueryService/ShareProfile" => {
                    #[allow(non_camel_case_types)]
                    struct ShareProfileSvc<T: QueryService>(pub Arc<T>);
                    impl<
                        T: QueryService,
                    > tonic::server::UnaryService<super::ShareProfileRequest>
                    for ShareProfileSvc<T> {
                        type Response = super::ShareProfileResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ShareProfileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as QueryService>::share_profile(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ShareProfileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for QueryServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "parca.query.v1alpha1.QueryService";
    impl<T> tonic::server::NamedService for QueryServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
